# 《大话数据结构》笔记

## 数据结构基本概念
1. 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。

2. 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。

3. 数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。

4. 数据元素：是组成数据、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。

5. 数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。

6. 数据对象：是性质相同的数据元素的集合，是数据的子集。

7. 数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。

8. 逻辑结构：是指数据对象中数据元素之间的相互关系。

    1. 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。

    2. 线性结构：线性结构中的数据元素之间是一对一的关系。

    3. 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。

    4. 图形结构：图形结构的数据元素是多对多的关系。

9. 物理结构：是指数据的逻辑结构在计算机中的存储形式。

    1. 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。

    2. 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。

10. 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

11. 抽象是指抽取出事物具有的普遍性的本质。

12. 抽象数据类型（Abstract Data Type，ADT）：是指一个数学模型及定义在该模型上的一组操作。

13. “抽象”的意义在于数据类型的数学抽象特性。

14. 抽象数据类型体现了程序设计中间问题分解、抽象和信息隐藏的特性。

## 算法
1. 算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的**有限**序列，并且每条指令表示一个或多个操作。

2. 算法的特性：

    1. 输入输出：算法具有零个或多个输入，至少有一个或多个输出。

    2. 有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无线循环，并且每一个步骤在可接受的时间内完成。

    3. 确定性：算法的每一步骤都具有确定的含义，不会出现二义性。

    4. 可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

3. 算法的设计要求：

    1. 正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反应问题的需求、能够得到问题的正确答案。

    2. 可读性：算法设计的另一目的是为了便于阅读、理解和交流。

    3. 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。

    4. 时间效率高和存储量低：设计算法应该尽量满足时间效率高和存储量低的需求。

4. 算法效率的度量方法：

    1. 事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时功能对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。

    2. 事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。

5. 算法时间复杂度：在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n)) 。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。其中 f(n) 是问题规模 n 的某个函数。

6. 常见的时间复杂度：

    |执行次数函数|阶|非正式术语|
    |:---|:---|:---|
    |12|O(1)|常数阶|
    |2n+3|O(n)|线性阶|
    |3n<sup>2</sup>+2n+1|O(n<sup>2</sup>)|平方阶|
    |5log<sub>2</sub>n+20|O(logn)|对数阶|
    |2n+3nlog<sub>2</sub>n+19|O(nlogn)|nlog<sub>2</sub>阶|
    |6n<sup>3</sup>+2n<sup>2</sup>+3n+4|O(n<sup>3</sup>)|立方阶|
    |2<sup>n</sup>|O(2<sup>n</sup>)|指数阶|

    排序：

    O(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)

7. 最坏情况运行时间是一种保证，那就是运行时间讲不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都将是最坏情况的运行时间。

8. 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。

9. 算法的空间复杂度：通过计算所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n)) ，其中 n 为问题的规模， f(n) 为语句关于 n 所占存储空间的函数。

## 线性表
### 基本概念
1. 线性表：零个或多个数据元素的**有限序列**。

2. 线性表元素的个数 n (n >= 0) 定义为线性表的长度，当 n=0 时，称为空表。

3 在较复杂的线性表中，一个数据元素可以由若干个数据项组成。

### 线性表的顺序存储结构
1. 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。

2. 线性表顺序存储结构的优缺点：

    1. 优点：

        - 无须为表示表中元素之间的逻辑关系而增加额外的存储空间

        - 可以快速地存取表中任一位置的元素

    2. 缺点：

        - 插入和删除操作需要移动大量元素

        - 当线性表长度变化较大时，难以确定存储空间的容量

        - 造成存储空间的“碎片”

### 线性表的链式存储结构
1. 线性表的链式存储结构，指的是 n 个节点链结成一个链表，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。

2. 结点是由存放数据元素的数据域和存放后继结点地址的指针域组成。

3. 链表中第一个结点的存储位置叫做**头指针**。

4. 头指针与头结点的异同：

    1. 头指针：

        - 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的**指针**。

        - 头指针具有标识作用，所以常用头指针冠以链表的名字。

        - 无论链表是否为空，头指针均不为空。头指针是链表的必要元素。

    2. 头结点：

        - 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）

        - 有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了。

        - 头结点不一定是链表必须要素。

5. 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。

6. 双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。

## 栈
1. 栈（stack）是限定仅在表尾进行插入和删除操作的线性表。

2. 允许插入和删除的一端称为**栈顶（top）**，另一端称为**栈底（bottom）**，不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out, LIFO）的线性表，简称 LIFO 结构。

3. 栈的插入操作，叫作进栈，也称压栈、入栈。

4. 栈的删除操作，叫作出栈，也有的叫作弹栈。

5. 栈的应用：

    1. **递归**：

        - 把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作**递归函数**。

        - 每个递归定义必须至少有一个**退出条件**，满足时递归不再进行，即不再引用自身而是返回值退出。

    2. **四则运算表达式求值**：

        - 后缀（逆波兰 Reverse Polish Notation，RPN）表示法

            **计算规则**：从左到右遍历表达式的每个数字和符号，遇到是**数字**就进栈，遇到是**符号**，就将处于栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。

        - **中缀**表达式转**后缀**表达式：

            **计算规则**：从左到右遍历中缀表达式的每个数字和符号，若是**数字**就输出，即成为后缀表达式的一部分；若是**符号**，则判断其与栈顶符号的**优先级**，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。

## 队列
1. 队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

2. 队列是一种先进先出（First In First Out，FIFO）的线性表，简称 FIFO。允许插入的一端叫**队尾**，允许删除的一端叫**队头**。

3. 把队列的这种**头尾相接**的顺序存储结构成为**循环队列**。

    - 循环队列判定元素满的条件：

        如果采用空一个元素使队列满时`rear != front`的判定方法，则队列满的条件是`(rear + 1) % QueueSize == front`

    - 循环队列长度公式：

        采用同上表示法时，通用公式为：`(rear - front + QueueSize) % QueueSize`

## 串
1. 串（string）是由零个或多个**字符**组成的**有限序列**，又名叫字符串。

2. 子串的定位操作通常称作串的**模式匹配**。

3. **KMP模式匹配算法tring**

## 树
### 树的基本概念
1. 树（Tree）是 n(n≥0) 个结点的有限集。n=0 时称为**空树**。在任意一棵非空树中：

    1. 有且仅有一个特定的称为**根（Root）**的结点

    2. 当 n>1 时，其余结点可分为 m(m>0) 个互不相交的有限集 T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的**子树（SubTree）**。

2. 结点拥有的子树称为**结点的度（Degree）**。度为 0 的结点称为**叶结点（Leaf）**或**终端结点**；度不为 0 的结点称为**非终端结点**或**分支结点**。除根结点之外，分支结点也称为**内部结点**。树的度是树内各结点的度的**最大值**。

3. 结点的子树的根称为该节点的**孩子（Child）**，相应地，该结点称为孩子的**双亲（Parent）**；同一个双亲的孩子之间互称**兄弟（Sibling）**；结点的**祖先**是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的**子孙**。

4. 结点的**层次（Level）**从根开始定义起，根为第一层，根的孩子为第二层。

5. 树中结点的**最大层次**称为树的**深度（Depth）**或**高度**。

6. 如果将树中结点的各子树看成从左到右是有次序的，不能互换的，则称该树为**有序树**，否则为**无序树**。

7. **森林（Forest）**是 m(m≥0) 棵互不相交的树的集合。

8. 树的存储结构：

    1. 双亲表示法

    2. 孩子表示法

    3. 孩子兄弟表示法（左孩子、右兄弟表示法）

### 二叉树
1. 二叉树（Binary Tree）是 n(n≥0) 个结点的有限集合，该集合或者为空集（称为**空二叉树**），或者由一个根节点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

2. 二叉树的特点

    - 每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。

    - 左子树和右子树是有顺序的，次序不能任意颠倒。

    - 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

3. 二叉树的五种基本形态

    - 空二叉树

    - 只有一个根结点

    - 根结点只有左子树

    - 根结点只有右子树

    - 根结点既有左子树又有右子树

4. 特殊二叉树

    1. 斜树

        所有的结点都只有左子树的二叉树叫**左斜树**；所有结点都只有右子树的树叫**右斜树**。这两者统称为**斜树**。

    2. 满二叉树

        在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为**满二叉树**。

        特点：

        1. 叶子只能出现在最下一层

        2. 非叶子结点的度一定是 2

        3. 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多

    3. 完全二叉树

        对一棵具有 n 个结点的二叉树**按层序**编号，如果编号为 i(1≤i≤n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为**完全二叉树**。

        *Tips：满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。*

        特点：

        1. 叶子结点只能出现在最下两层

        2. 最下层的叶子一定集中在左部连续位置

        3. 倒数二层，若有叶子结点，一定都在右部连续位置

        4. 如果结点度为 1，则该结点只有左孩子，即不存在只有右子树的情况

        5. 同样结点数的二叉树，完全二叉树的深度最小

5. 二叉树的性质

    1. 在二叉树的第 i 层上至多有 2<sup>i-1</sup>个结点 (i≥1)

    2. 深度为 k 的二叉树至多有 2<sup>k</sup>-1 个结点 (k≥1)

    3. 对任何一棵二叉树 T，如果其终端结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub>=n<sub>2</sub>+1

    4. 具有 n 个结点的完全二叉树的深度为 ⌊log<sub>2</sub>n⌋+1 (⌊x⌋ 表示不大于 x 的最大整数)

    5. 如果对一棵有 n 个结点的完全二叉树（其深度为 ⌊log<sub>2</sub>n⌋+1）的结点按层序编号（从第 1 层到第 ⌊log<sub>2</sub>n⌋+1 层，每层从左到右），对任一结点 i(1≤i≤n) 有：

        1. 如果 i=1，则结点 i 是二叉树的根，无双亲；如果 i>1，则其双亲是结点 ⌊i/2⌋

        2. 如果 2i>n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i

        3. 如果 2i+1>n，则结点 i 无有孩子；否则其右孩子是结点 2i+1

6. 二叉树的存储结构

    1. **二叉树顺序存储结构**：用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系（一般按完全二叉树的序号来进行分配）

    2. **二叉链表**

7. 二叉树的遍历

    1. 定义：**二叉树的遍历（traversing binary tree）**是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点**被访问一次且仅被访问一次**。

    2. 方式：

        1. 前序遍历（根左右）

        2. 中序遍历（左根右）

        3. 后序遍历（左右根）

        4. 层序遍历：若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。