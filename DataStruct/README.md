# 《大话数据结构》笔记

## 数据结构基本概念
1. 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。

2. 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。

3. 数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。

4. 数据元素：是组成数据、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。

5. 数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。

6. 数据对象：是性质相同的数据元素的集合，是数据的子集。

7. 数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。

8. 逻辑结构：是指数据对象中数据元素之间的相互关系。

    1. 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。

    2. 线性结构：线性结构中的数据元素之间是一对一的关系。

    3. 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。

    4. 图形结构：图形结构的数据元素是多对多的关系。

9. 物理结构：是指数据的逻辑结构在计算机中的存储形式。

    1. 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。

    2. 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。

10. 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

11. 抽象是指抽取出事物具有的普遍性的本质。

12. 抽象数据类型（Abstract Data Type，ADT）：是指一个数学模型及定义在该模型上的一组操作。

13. “抽象”的意义在于数据类型的数学抽象特性。

14. 抽象数据类型体现了程序设计中间问题分解、抽象和信息隐藏的特性。

## 算法
1. 算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的**有限**序列，并且每条指令表示一个或多个操作。

2. 算法的特性：

    1. 输入输出：算法具有零个或多个输入，至少有一个或多个输出。

    2. 有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无线循环，并且每一个步骤在可接受的时间内完成。

    3. 确定性：算法的每一步骤都具有确定的含义，不会出现二义性。

    4. 可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

3. 算法的设计要求：

    1. 正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反应问题的需求、能够得到问题的正确答案。

    2. 可读性：算法设计的另一目的是为了便于阅读、理解和交流。

    3. 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。

    4. 时间效率高和存储量低：设计算法应该尽量满足时间效率高和存储量低的需求。

4. 算法效率的度量方法：

    1. 事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时功能对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。

    2. 事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。

5. 算法时间复杂度：在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n)) 。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。其中 f(n) 是问题规模 n 的某个函数。

6. 常见的时间复杂度：

    |执行次数函数|阶|非正式术语|
    |:---|:---|:---|
    |12|O(1)|常数阶|
    |2n+3|O(n)|线性阶|
    |3n<sup>2</sup>+2n+1|O(n<sup>2</sup>)|平方阶|
    |5log<sub>2</sub>n+20|O(logn)|对数阶|
    |2n+3nlog<sub>2</sub>n+19|O(nlogn)|nlog<sub>2</sub>阶|
    |6n<sup>3</sup>+2n<sup>2</sup>+3n+4|O(n<sup>3</sup>)|立方阶|
    |2<sup>n</sup>|O(2<sup>n</sup>)|指数阶|

    排序：

    O(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)

7. 最坏情况运行时间是一种保证，那就是运行时间讲不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都将是最坏情况的运行时间。

8. 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。

9. 算法的空间复杂度：通过计算所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n)) ，其中 n 为问题的规模， f(n) 为语句关于 n 所占存储空间的函数。

## 线性表
### 基本概念
1. 线性表：零个或多个数据元素的**有限序列**。

2. 线性表元素的个数 n (n >= 0) 定义为线性表的长度，当 n=0 时，称为空表。

3 在较复杂的线性表中，一个数据元素可以由若干个数据项组成。

### 线性表的顺序存储结构
1. 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。

2. 线性表顺序存储结构的优缺点：

    1. 优点：

        - 无须为表示表中元素之间的逻辑关系而增加额外的存储空间

        - 可以快速地存取表中任一位置的元素

    2. 缺点：

        - 插入和删除操作需要移动大量元素

        - 当线性表长度变化较大时，难以确定存储空间的容量

        - 造成存储空间的“碎片”

### 线性表的链式存储结构
1. 线性表的链式存储结构，指的是 n 个节点链结成一个链表，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。

2. 结点是由存放数据元素的数据域和存放后继结点地址的指针域组成。

3. 链表中第一个结点的存储位置叫做**头指针**。

4. 头指针与头结点的异同：

    1. 头指针：

        - 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的**指针**。

        - 头指针具有标识作用，所以常用头指针冠以链表的名字。

        - 无论链表是否为空，头指针均不为空。头指针是链表的必要元素。

    2. 头结点：

        - 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）

        - 有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了。

        - 头结点不一定是链表必须要素。

5. 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。

6. 双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。

## 栈
1. 栈（stack）是限定仅在表尾进行插入和删除操作的线性表。

2. 允许插入和删除的一端称为**栈顶（top）**，另一端称为**栈底（bottom）**，不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out, LIFO）的线性表，简称 LIFO 结构。

3. 栈的插入操作，叫作进栈，也称压栈、入栈。

4. 栈的删除操作，叫作出栈，也有的叫作弹栈。

5. 栈的应用：

    1. **递归**：

        - 把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作**递归函数**。

        - 每个递归定义必须至少有一个**退出条件**，满足时递归不再进行，即不再引用自身而是返回值退出。

    2. **四则运算表达式求值**：

        - 后缀（逆波兰 Reverse Polish Notation，RPN）表示法

            **计算规则**：从左到右遍历表达式的每个数字和符号，遇到是**数字**就进栈，遇到是**符号**，就将处于栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。

        - **中缀**表达式转**后缀**表达式：

            **计算规则**：从左到右遍历中缀表达式的每个数字和符号，若是**数字**就输出，即成为后缀表达式的一部分；若是**符号**，则判断其与栈顶符号的**优先级**，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。

## 队列
1. 队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

2. 队列是一种先进先出（First In First Out，FIFO）的线性表，简称 FIFO。允许插入的一端叫**队尾**，允许删除的一端叫**队头**。

3. 把队列的这种**头尾相接**的顺序存储结构成为**循环队列**。

    - 循环队列判定元素满的条件：

        如果采用空一个元素使队列满时`rear != front`的判定方法，则队列满的条件是`(rear + 1) % QueueSize == front`

    - 循环队列长度公式：

        采用同上表示法时，通用公式为：`(rear - front + QueueSize) % QueueSize`

## 串
1. 串（string）是由零个或多个**字符**组成的**有限序列**，又名叫字符串。

2. 子串的定位操作通常称作串的**模式匹配**。

3. **KMP模式匹配算法tring**

## 树
### 树的基本概念
1. 树（Tree）是 n(n≥0) 个结点的有限集。n=0 时称为**空树**。在任意一棵非空树中：

    1. 有且仅有一个特定的称为**根（Root）**的结点

    2. 当 n>1 时，其余结点可分为 m(m>0) 个互不相交的有限集 T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的**子树（SubTree）**。

2. 结点拥有的子树称为**结点的度（Degree）**。度为 0 的结点称为**叶结点（Leaf）**或**终端结点**；度不为 0 的结点称为**非终端结点**或**分支结点**。除根结点之外，分支结点也称为**内部结点**。树的度是树内各结点的度的**最大值**。

3. 结点的子树的根称为该节点的**孩子（Child）**，相应地，该结点称为孩子的**双亲（Parent）**；同一个双亲的孩子之间互称**兄弟（Sibling）**；结点的**祖先**是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的**子孙**。

4. 结点的**层次（Level）**从根开始定义起，根为第一层，根的孩子为第二层。

5. 树中结点的**最大层次**称为树的**深度（Depth）**或**高度**。

6. 如果将树中结点的各子树看成从左到右是有次序的，不能互换的，则称该树为**有序树**，否则为**无序树**。

7. **森林（Forest）**是 m(m≥0) 棵互不相交的树的集合。

8. 树的存储结构：

    1. 双亲表示法

    2. 孩子表示法

    3. 孩子兄弟表示法（左孩子、右兄弟表示法）

### 二叉树
1. 二叉树（Binary Tree）是 n(n≥0) 个结点的有限集合，该集合或者为空集（称为**空二叉树**），或者由一个根节点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

2. 二叉树的特点

    - 每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。

    - 左子树和右子树是有顺序的，次序不能任意颠倒。

    - 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

3. 二叉树的五种基本形态

    - 空二叉树

    - 只有一个根结点

    - 根结点只有左子树

    - 根结点只有右子树

    - 根结点既有左子树又有右子树

4. 特殊二叉树

    1. 斜树

        所有的结点都只有左子树的二叉树叫**左斜树**；所有结点都只有右子树的树叫**右斜树**。这两者统称为**斜树**。

    2. 满二叉树

        在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为**满二叉树**。

        特点：

        1. 叶子只能出现在最下一层

        2. 非叶子结点的度一定是 2

        3. 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多

    3. 完全二叉树

        对一棵具有 n 个结点的二叉树**按层序**编号，如果编号为 i(1≤i≤n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为**完全二叉树**。

        *Tips：满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。*

        特点：

        1. 叶子结点只能出现在最下两层

        2. 最下层的叶子一定集中在左部连续位置

        3. 倒数二层，若有叶子结点，一定都在右部连续位置

        4. 如果结点度为 1，则该结点只有左孩子，即不存在只有右子树的情况

        5. 同样结点数的二叉树，完全二叉树的深度最小

5. 二叉树的性质

    1. 在二叉树的第 i 层上至多有 2<sup>i-1</sup>个结点 (i≥1)

    2. 深度为 k 的二叉树至多有 2<sup>k</sup>-1 个结点 (k≥1)

    3. 对任何一棵二叉树 T，如果其终端结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub>=n<sub>2</sub>+1

    4. 具有 n 个结点的完全二叉树的深度为 ⌊log<sub>2</sub>n⌋+1 (⌊x⌋ 表示不大于 x 的最大整数)

    5. 如果对一棵有 n 个结点的完全二叉树（其深度为 ⌊log<sub>2</sub>n⌋+1）的结点按层序编号（从第 1 层到第 ⌊log<sub>2</sub>n⌋+1 层，每层从左到右），对任一结点 i(1≤i≤n) 有：

        1. 如果 i=1，则结点 i 是二叉树的根，无双亲；如果 i>1，则其双亲是结点 ⌊i/2⌋

        2. 如果 2i>n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i

        3. 如果 2i+1>n，则结点 i 无有孩子；否则其右孩子是结点 2i+1

6. 二叉树的存储结构

    1. **二叉树顺序存储结构**：用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系（一般按完全二叉树的序号来进行分配）

    2. **二叉链表**

7. 二叉树的遍历

    1. 定义：**二叉树的遍历（traversing binary tree）**是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点**被访问一次且仅被访问一次**。

    2. 方式：

        1. 前序遍历（根左右）

        2. 中序遍历（左根右）

        3. 后序遍历（左右根）

        4. 层序遍历：若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。

8. 线索二叉树

    1. 指向前驱和后继的指针称为**线索**，加上线索的二叉链表称为**线索链表**，相应的二叉树就称为**线索二叉树（Threaded Binary Tree）**。

    2. 对二叉树以某种次序遍历使其变为线索二叉树的过程称作是**线索化**。

    3. 为了区分结点的左孩子到底是它的左孩子还是它的前驱，右孩子到底是它的右孩子还是后继，需为每个结点再增设两个**标志域（ltag 和 rtag）**，注意，ltag 和 rtag 只存放 0 和 1，为 0 时表示指向的是孩子，为 1 表示指向的是前驱或后继。

    4. 线索化的过程就是在遍历的过程中修改空指针的过程。

    5. 如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。

### 树、森林与二叉树的转换
1. 树转换成二叉树（左孩子右兄弟法）

2. 森林转换成二叉树：先把每棵树根据上面的规则转换成二叉树，再将第一棵二叉树的根结点作为根，其他二叉树的根结点作为该根结点的右孩子（即将所有的二叉树视作兄弟）

3. 森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。

### 赫夫曼树及其应用
1. 从树中一个结点到另一个结点之间的分支构成两个结点之间的**路径**，路径上的分支数目称作**路径长度**。

2. 树的路径长度就是从树根到每一个结点的路径长度之和。

3. 结点的**带权路径长度**为从该结点到树根之间的路径长度与结点上权的乘积。

4. 树的**带权路径长度**为树中所有**叶子结点**的带权路径长度之和。

5. **带权路径长度 WPL** 最小的二叉树称作赫夫曼树。

6. 一般地，设需要编码的字符集为 { d<sub>1</sub>, d<sub>2</sub>, ... , d<sub>n</sub> }，各个字符在电文中出现的次数或频率集合为 { w<sub>1</sub>, w<sub>2</sub>, ... , w<sub>n</sub> }，以 d<sub>1</sub>, d<sub>2</sub>, ... , d<sub>n</sub>作为叶子结点，以 w<sub>1</sub>, w<sub>2</sub>, ... , w<sub>n</sub> 作为相应的叶子结点的权值来构造一棵赫夫曼树。规定**赫夫曼树的左分支代表 0，右分支代表 1**，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的**编码**，这就是**赫夫曼编码**。

## 图
### 图的定义
#### 基本概念
1. **图（Graph）**是由顶点的**有穷非空**集合和定点之间边的集合组成，通常表示为：G(V, E)，其中 G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。

2. 在图中数据元素，我们称为**顶点（Vertex）**。

3. 在图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，**边集可以是空的**。

#### 各种图定义
1. 无向边：若顶点 v<sub>i</sub> 到 v<sub>j</sub> 之间的边没有方向，则称这条边为**无向边（Edge）**，用**无序偶对 (v<sub>i</sub>, v<sub>j</sub>)** 来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为**无向图（Undirected graphs）**。

2. 有向边：若顶点 v<sub>i</sub> 到 v<sub>j</sub> 的边有方向，则称这条边为**有向边**，也称为**弧（Arc）**。用**有序偶对 \<v<sub>i</sub>, v<sub>j</sub>\>** 来表示，v<sub>i</sub> 称为**弧尾（Tail）**，v<sub>j</sub> 称为**弧头（Head）**。如果图中任意两个顶点之间的边都是有向边，则称改图为**有向图（Directed graphs）**。

3. 在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为**简单图**。

4. 在无向图中，如果任意两个顶点之间都存在边，则称该图为**无向完全图**。含有 n 个顶点的无向完全图有 n*(n-1)/2 条边。

5. 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为**有向完全图**。含有 n 个顶点的有向完全图有 n*(n-1) 条边。

6. 有很少条边或弧的图称为**稀疏图**，反之称为**稠密图**。稀疏与稠密是相对的。

7. 有些图的边或弧具有与它相关的数字，这些数字称为权值，这种带权的图通常称为**网（Network）**。

8. 假设有两个图 G=(V, {E}) 和 G'=(V', {E'})，如果 V'属于 V 且 E' 属于 E，则称 G' 为 G 的**子图（Subgraph）**。

#### 图的顶点与边的关系
1. 对于无向图 G=(V, {E})，如果边 (v, v')∈E，则称顶点 v 和 v' 互为**邻接点（Adjacent）**，即 v 和 v' 相邻接。边 (v, v') **依附（incident）**于顶点 v 和 v'，或者说 (v, v') 与顶点 v 和 v' 相**关联**。

2. 顶点的**度（Degree）**是和该顶点相关联的边的数目。记为 TD(v)。

3. 对于有向图 G=(V, {E})，如果弧 \<v, v'\>∈E，则称顶点 v 邻接**到**顶点 v' ，顶点 v' 邻接**自**顶点 v。弧 \<v, v'\> 和顶点 v，v' 相关联。以顶点 v 为**头**的弧的数目称为 v 的**入度（InDegree）**，记为 ID(v)；以 v 为**尾**的弧的数目称为 v 的**出度（OutDegree）**，记为 OD(v)；顶点 v 的度为 TD(v)=ID(v)+OD(v)。

4. 无向图 G=(V, {E}) 中从顶点 v 到顶点 v' 的**路径（Path）**是一个顶点序列（v=v<sub>i,0</sub>, v<sub>i,1</sub>, ... , v<sub>i,m</sub>=v'），其中 (v<sub>i,j-1</sub>, v<sub>i, j</sub>)∈E, 1≤j≤m。

5. 路径的长度是路径上的边或弧的数目。

6. 第一个顶点到最后一个顶点相同的路径称为**回路**或**环（Cycle）**。

#### 连通图相关术语
1. 在无向图 G 中，如果从顶点 v 到顶点 v' 有路径，则称 v 和 v' 是连通的。如果对于图中任意两个顶点 v<sub>i</sub>、v<sub>j</sub>∈V, v<sub>i</sub> 和 v<sub>j</sub> 都是连通的，则称 G 是**连通图（Connected Graph）**。

2. 无向图中的**极大**连通子图称为**连通分量**。

3. 在有向图 G 中，如果对于每一对 v<sub>i</sub>、v<sub>j</sub>∈V、v<sub>i</sub>≠v<sub>j</sub>，从 v<sub>i</sub> 到 v<sub>j</sub> 都存在路径，则称 G 是**强连通图**。有向图中的极大强连通子图称作有向图的**强连通分量**。

4. 一个连通图的**生成树**是一个极小的连通子图，它含有图中全部的 n 个顶点，但只有足以构成一棵树的 n-1 条边。

5. 一个图，有 n 个顶点，如果有小于 n-1 条边，则这个图是非连通图，如果有多于 n-1 条边，则必定存在环，但是，**就算有 n-1 条边也不一定是连通图**。

6. 如果一个有向图恰有一个顶点入度为0，其余顶点的入度均为1，则是一棵**有向树**。

7. 一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。

### 图的存储结构
1. 邻接矩阵：

    图的**邻接矩阵（Adjacency Matrix）**存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。

2. 邻接表：

    将数组与链表相结合的存储方式称为**邻接表（Adjacency List）**

    其中，图中顶点用一个以为数组存储，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针。

3. 十字链表（Orthogonal List）

4. 邻接多重表

5. 边集数组

    边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的**起点下标（begin）**、**终点下标（end）**和**权（weight）**组成。

### 图的遍历
1. 概念

    从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫**图的遍历（Traversing Graph）**。

2. 深度优先遍历（Depth First Search），也有称为**深度优先搜索**，简称为 DFS。

3. 广度优先遍历（Breadth First Search），又称为**广度优先搜索**，简称为 BFS。

### 最小生成树
1. 概念

    构造连通网的最小代价生成树称为**最小生成树（Minimum Cost Spanning Tree）**。

2. 普里姆（Prim）算法

3. 克鲁斯卡尔（Kruskal）算法

4. **注意**：对比上面的两个算法，克鲁斯卡尔算法主要针对边来展开，边数少时效率会非常高，所以说对于稀疏图有很大的优势；而普里姆算法对于稠密图，即边数非常多的情况会更好一些。

### 最短路径
1. 概念

    对于**网图**来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是**源点**，最后一个点是**终点**。而对于**非网图**来说，最短路径，就是指两顶点之间经过的边数最少的路径。

2. 迪杰斯特拉（Dijkstra）算法

3. 弗洛伊德（Floyd）算法

4. **注意**：如果你面临需要求所有顶点至所有顶点的最短路径问题时，弗洛伊德（Floyd）算法应该是不错的选择。

### 拓扑排序
1. 概念

    在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为**AOV网（Activity On Vertex Network)**

    设 G=(V, E)是一个具有 n 个顶点的有向图，V 中的顶点序列 v<sub>1</sub>，v<sub>2</sub>，……，v<sub>n</sub>，满足若从顶点 v<sub>i</sub> 到 v<sub>j</sub> 有一条路径，则在顶点序列中顶点 v<sub>i</sub> 必在顶点 v<sub>j</sub> 之前。则我们称这样的顶点序列为一个**拓扑序列**。

    所谓**拓扑排序**，其实就是对一个有向图构造拓扑序列的过程。

2. 拓扑排序算法

    基本思路：从 AOV 网中选择一个入度为 0 的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者 AOV 网中不存在入度为 0 的顶点为止。

### 关键路径
1. 概念

    - 在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为 **AOE 网（Activity On Edge Network）**

    - AOE 网中没有入边的顶点称为**源点**或**始点**

    - AOE 网中没有出边的顶点称为**汇点**或**终点**

    - 路径上各个活动所持续的时间之和称为**路径长度**，从**源点**到**汇点**具有最大长度的路径叫**关键路径**，在**关键路径**上的活动叫**关键活动**。

## 查找
### 基本概念

- **查找表（Search Table）**是由同一类型的数据元素（或记录）构成的集合。

- **关键词（Key）**是数据元素中某个数据项的值

- 若此关键字可以唯一地标识一个记录，则称此关键字为**主关键字（Primary Key）**

- 可以识别多个数据元素（或记录）的关键字，称为**次关键字（Secondary Key）**

- **静态查找表（Static Search Table）**：只作查找操作的查找表

- **动态查找表（Dynamic Search Table）**：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素

### 顺序表查找
1. 概念

    **顺序查找（Sequential Search）**又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。

### 有序表查找
1. 折半查找

    **折半查找（Binary Search）**技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。

2. 插值查找

    **插值查找（Interpolation Search）**是根据要查找的关键字 key 与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])。

3. 斐波那契查找

### 线性索引查找
1. 概念

    - 索引就是把一个关键字与它对应的记录相关联的过程。

    - 所谓线性索引就是将索引项集合组织为**线性结构**，也称为**索引表**。

2. 稠密索引

    - **稠密索引**是指在线性索引中，将数据集中的每个记录对应一个索引项

    - 对于稠密索引这个索引表来说，索引项一定是按照**关键码**有序的排列。

3. 分块索引

    - 对数据集进行分块，使其**分块有序**，然后再对每一块建立一个索引项，从而减少索引项的个数

    - **分块有序**，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：

        - **块内无序**，即每一块内的记录不要求有序。当然，如果能够让块内有序对查找来说更理想。

        - **块间有序**，要求后一块所有记录的关键字必须大于前一块中所有记录的关键字等。

4. 倒排索引

    - 索引项的通用结构是：

        - **次关键码**

        - **记录号表**

        其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是**倒排索引（inverted index）。**

### 二叉排序树
1. 概念

    **二叉排序树（Binary Sort Tree）**，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树：

        - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值

        - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值

        - 它的左、右子树也分别为二叉排序树

### 平衡二叉树（AVL树）
1. 概念

    - **平衡二叉树（Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree）**，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于 1

    - 将二叉树上结点的左子树深度减去右子树深度的值称为**平衡因子 BF（Balance Factor）**

    - 距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树，称为**最小不平衡子树**

### 多路查找树（B树）
1. 概念

    **多路查找树（mutil-way search tree）**，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。

2. 2-3 树

    - 2-3 树是这样的一棵**多路查找树**：其中的每一个结点都具有两个孩子（我们称它为 2 结点）或三个孩子（我们称它为 3 结点）

    - 一个 2 结点包含一个元素和两个孩子（或没有孩子）

    - 一个 3 结点包含一小一大两个元素和三个孩子（或没有孩子）

3. 2-3-4 树

    是 2-3 树的扩展，包括了 4 结点的使用。一个 4 结点包含小中大三个元素和四个孩子（或没有孩子），一个 4 结点要么没有孩子，要么具有 4 个孩子。

4. **B 树**

    - **B 树（B-tree）**是一种**平衡的多路查找树**，2-3 树和 2-3-4 树都是 B 树的特例。结点最大的孩子数目称为 B 树的**阶（order）**

    - 一个 m 阶的 B 树具有如下属性：

        - 如果根结点不是叶结点，则其至少有两棵子树

        - 每一个非根的分支结点都有 k-1 个元素和 k 个孩子，其中 ⌈m/2⌉≤k≤m。每一个叶子结点 n 都有 k-1 个元素，其中 ⌈m/2⌉≤k≤m

        - 所有叶子结点都位于同一层次

        - 所有分支结点包含下列信息数据（n, A<sub>0</sub>, K<sub>1</sub>, A<sub>1</sub>, K<sub>2</sub>, ... , K<sub>n</sub>, A<sub>n</sub>），其中：K<sub>i</sub> (i=1, 2, ..., n) 为**关键字**，且 K<sub>i</sub>\<K<sub>i+1</sub> (i=1, 2, ... , n); A<sub>i</sub> (i=0, 2, ... , n) 为指向子树根结点的指针，且指针 A<sub>i-1</sub> 所指子树中所有结点的关键字均小于 K<sub>i</sub> (i=1, 2, ... , n)，A<sub>n</sub> 所指子树中所有结点的关键字均大于 K<sub>n</sub>，n (⌈m/2⌉-1≤n≤m-1) 为关键字的个数（或 n+1 为子树的个数）

5. B+ 树

    - B+ 树是应文件系统所需而出的一种 B 树的变形树，注意严格意义上讲，它已经不是树这种数据结构了。在 B 树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在 B+ 树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次出现。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。

    - 一棵 m 阶的 B+ 树和 m 阶的 B 树的差异在于：

        - 有 n 棵子树的结点中包含有 n 个关键字

        - 所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接

        - 所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字

### 散列表查找（哈希表）
1. 概念

    - **散列技术**是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字 key 对应一个存储位置 f(key)

    - 采用**散列技术**将记录存储在一块连续的存储空间中，这块连续存储空间称为**散列表**或**哈希表（Hash table）**

    - 散列技术既是一种存储方法，也是一种查找方法

    - 散列技术最适合的求解问题是查找与给定值相等的记录

    - 两个关键字 key<sub>1</sub>≠key<sub>2</sub>，但是却有 f(key<sub>1</sub>)=f(key<sub>2</sub>)，这种现象称为**冲突（collision）**，并把 key<sub>1</sub> 和 key<sub>2</sub> 称为这个散列函数的**同义词（synonym）**

2. 散列函数的构造方法

    1. 直接定址法

        取关键字的某个线性函数值为散列地址：`f(key) = a * key + b`

    2. 数字分析法

    3. 平方取中法

    4. 折叠法

    5. **除留余数法**

        `f(key) = key mod p (p <= m)`

    6. 随机数法

3. 处理散列冲突的方法

    1. 开放定址法

        所谓**开放定址法**就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。公式为`fi(key) = (f(key) + di) mod m (di = 1, 2, 3, ... , m-1)`

    2. 再散列函数法

        实现准备多个散列函数，如果发生冲突，就换一个散列函数计算，相信总会有一个可以把冲突解决掉

    3. 链地址法

    4. 公共溢出区法

4. 散列表查找性能分析

    1. 散列函数是否均匀

    2. 处理冲突的方法

    3. 散列表的装填因子

## 排序
### 基本概念

- 假设含有 n 个记录的序列为 {r<sub>1</sub>, r<sub>2</sub>, ... , r<sub>n</sub>}，其相应的关键字分别为 {k<sub>1</sub>, k<sub>2</sub>, ... , k<sub>n</sub>}，需确定1, 2, ... , n的一种排列 p<sub>1</sub>, p<sub>2</sub>, ... , p<sub>n</sub>，使其相应的关键字满足 k<sub>p1</sub>≤k<sub>p2</sub>≤...≤k<sub>pn</sub>（非递减或非递增）关系，即使得序列成为一个按关键字有序的序列 {r<sub>p1</sub>, r<sub>p2</sub>, ... , r<sub>pn</sub>}，这样的操作就称为**排序**

- **排序的稳定性**：假设 k<sub>i</sub>=k<sub>j</sub> (1≤i≤n, 1≤j≤n, i≠j)，且在排序前的序列中 r<sub>i</sub> 领先于 r<sub>j</sub> （即 i<j）。如果排序后 r<sub>i</sub> 仍领先于 r<sub>j</sub>，则称所用的排序方法是稳定的；反之，则称所用的排序方法是不稳定的。

- **内排序**：是指在排序过程中，待排序的所有记录全部被放置在内存中

- **外排序**：是指由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行

### 冒泡排序
1. 概念

    **冒泡排序（Bubble Sort）**一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止

2. 时间复杂度

    优化后的时间复杂度：最好情况为 O(n)，最坏情况为 O(n<sup>2</sup>)，因此总的时间复杂度为 O(n<sup>2</sup>)

### 简单选择排序
1. 概念

    **简单选择排序法（Simple Selection Sort）**就是通过 n-i 次关键字间的比较，从 n-i+1 个记录中选出关键字最小的记录，并和第 i (1≤i≤n) 个记录交换之

2. 时间复杂度

    无论好坏时间复杂度都为 O(n<sup>2</sup>)，因此总的时间复杂度为 O(n<sup>2</sup>)

### 直接插入排序
1. 概念

    **直接插入排序（Straight Insertion Sort）**的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增 1 的有序表

2. 时间复杂度

    最好情况为 O(n)，最查情况为 O(n<sup>2</sup>)，因此总的时间复杂度为 O(n<sup>2</sup>)

3. 空间复杂度

    只需要一个记录的辅助空间

### 希尔排序
1. 概念

    - 基本思路：将原本有大量记录数的记录进行分组，分割成若干个子序列，此时每个子序列待排序的记录个数就比较少了，然后在这些子序列内分别进行直接插入排序，当整个序列都**基本有序**时，再对全体记录进行一次直接插入排序

    - **基本有序**，小的关键字基本在前面，大的基本在后面，不大不小的基本在中间

    - 跳跃分割的策略：将相距某个“增量“的记录组成一个子序列，这样才能保证子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序

    - **注意**：由于记录是跳跃式的移动，希尔排序并不是一种**稳定**排序算法

2. 时间复杂度

    与“**增量**”有关，当增量序列为 dlta[k] = 2<sup>t-k+1</sup>-1 (0≤k≤t≤⌊log<sub>2</sub>(n+1)⌋) 时，其时间复杂度为 O(n<sup>3/2</sup>)

### 堆排序
1. 概念

    - **堆**是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为**大顶堆**；或者每个结点的值都小于或等于其左右孩子结点的值，称为**小顶堆**

    - 根结点一定是堆中所有结点最大（小）者

    - **堆排序（Heap Sort）**基本思想是：将待排序的序列构成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩下的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次小值。如此反复执行，便能得到一个有序序列了。