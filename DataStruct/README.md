# 《大话数据结构》笔记

## 数据结构基本概念
1. 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。

2. 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。

3. 数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。

4. 数据元素：是组成数据、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。

5. 数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。

6. 数据对象：是性质相同的数据元素的集合，是数据的子集。

7. 数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。

8. 逻辑结构：是指数据对象中数据元素之间的相互关系。

    1. 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。

    2. 线性结构：线性结构中的数据元素之间是一对一的关系。

    3. 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。

    4. 图形结构：图形结构的数据元素是多对多的关系。

9. 物理结构：是指数据的逻辑结构在计算机中的存储形式。

    1. 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。

    2. 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。

10. 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

11. 抽象是指抽取出事物具有的普遍性的本质。

12. 抽象数据类型（Abstract Data Type，ADT）：是指一个数学模型及定义在该模型上的一组操作。

13. “抽象”的意义在于数据类型的数学抽象特性。

14. 抽象数据类型体现了程序设计中间问题分解、抽象和信息隐藏的特性。

## 算法
1. 算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的**有限**序列，并且每条指令表示一个或多个操作。

2. 算法的特性：

    1. 输入输出：算法具有零个或多个输入，至少有一个或多个输出。

    2. 有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无线循环，并且每一个步骤在可接受的时间内完成。

    3. 确定性：算法的每一步骤都具有确定的含义，不会出现二义性。

    4. 可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

3. 算法的设计要求：

    1. 正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反应问题的需求、能够得到问题的正确答案。

    2. 可读性：算法设计的另一目的是为了便于阅读、理解和交流。

    3. 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。

    4. 时间效率高和存储量低：设计算法应该尽量满足时间效率高和存储量低的需求。

4. 算法效率的度量方法：

    1. 事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时功能对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。

    2. 事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。

5. 算法时间复杂度：在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n)) 。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。其中 f(n) 是问题规模 n 的某个函数。

6. 常见的时间复杂度：

    |执行次数函数|阶|非正式术语|
    |:---|:---|:---|
    |12|O(1)|常数阶|
    |2n+3|O(n)|线性阶|
    |3n<sup>2</sup>+2n+1|O(n<sup>2</sup>)|平方阶|
    |5log<sub>2</sub>n+20|O(logn)|对数阶|
    |2n+3nlog<sub>2</sub>n+19|O(nlogn)|nlog<sub>2</sub>阶|
    |6n<sup>3</sup>+2n<sup>2</sup>+3n+4|O(n<sup>3</sup>)|立方阶|
    |2<sup>n</sup>|O(2<sup>n</sup>)|指数阶|

    排序：

    O(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)

7. 最坏情况运行时间是一种保证，那就是运行时间讲不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都将是最坏情况的运行时间。

8. 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。

9. 算法的空间复杂度：通过计算所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n)) ，其中 n 为问题的规模， f(n) 为语句关于 n 所占存储空间的函数。

## 线性表
### 基本概念
1. 线性表：零个或多个数据元素的**有限序列**。

2. 线性表元素的个数 n (n >= 0) 定义为线性表的长度，当 n=0 时，称为空表。

3 在较复杂的线性表中，一个数据元素可以由若干个数据项组成。

### 线性表的顺序存储结构
1. 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。

2. 线性表顺序存储结构的优缺点：

    1. 优点：

        - 无须为表示表中元素之间的逻辑关系而增加额外的存储空间

        - 可以快速地存取表中任一位置的元素

    2. 缺点：

        - 插入和删除操作需要移动大量元素

        - 当线性表长度变化较大时，难以确定存储空间的容量

        - 造成存储空间的“碎片”

### 线性表的链式存储结构
1. 线性表的链式存储结构，指的是 n 个节点链结成一个链表，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。

2. 结点是由存放数据元素的数据域和存放后继结点地址的指针域组成。

3. 链表中第一个结点的存储位置叫做**头指针**。

4. 头指针与头结点的异同：

    1. 头指针：

        - 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的**指针**。

        - 头指针具有标识作用，所以常用头指针冠以链表的名字。

        - 无论链表是否为空，头指针均不为空。头指针是链表的必要元素。

    2. 头结点：

        - 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）

        - 有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了。

        - 头结点不一定是链表必须要素。

5. 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。

6. 双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。

## 栈
1. 栈（stack）是限定仅在表尾进行插入和删除操作的线性表。

2. 允许插入和删除的一端称为**栈顶（top）**，另一端称为**栈底（bottom）**，不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out, LIFO）的线性表，简称 LIFO 结构。

3. 栈的插入操作，叫作进栈，也称压栈、入栈。

4. 栈的删除操作，叫作出栈，也有的叫作弹栈。

5. 栈的应用：

    1. **递归**：

        - 把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作**递归函数**。

        - 每个递归定义必须至少有一个**退出条件**，满足时递归不再进行，即不再引用自身而是返回值退出。

    2. **四则运算表达式求值**：

        - 后缀（逆波兰 Reverse Polish Notation，RPN）表示法

            **计算规则**：从左到右遍历表达式的每个数字和符号，遇到是**数字**就进栈，遇到是**符号**，就将处于栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。

        - **中缀**表达式转**后缀**表达式：

            **计算规则**：从左到右遍历中缀表达式的每个数字和符号，若是**数字**就输出，即成为后缀表达式的一部分；若是**符号**，则判断其与栈顶符号的**优先级**，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。

## 队列
1. 队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

2. 队列是一种先进先出（First In First Out，FIFO）的线性表，简称 FIFO。允许插入的一端叫**队尾**，允许删除的一端叫**队头**。

3. 把队列的这种**头尾相接**的顺序存储结构成为**循环队列**。

    - 循环队列判定元素满的条件：

        如果采用空一个元素使队列满时`rear != front`的判定方法，则队列满的条件是`(rear + 1) % QueueSize == front`

    - 循环队列长度公式：

        采用同上表示法时，通用公式为：`(rear - front + QueueSize) % QueueSize`

## 串
1. 串（string）是由零个或多个**字符**组成的**有限序列**，又名叫字符串。

2. 子串的定位操作通常称作串的**模式匹配**。

3. **KMP模式匹配算法tring**

## 树
### 树的基本概念
1. 树（Tree）是 n(n≥0) 个结点的有限集。n=0 时称为**空树**。在任意一棵非空树中：

    1. 有且仅有一个特定的称为**根（Root）**的结点

    2. 当 n>1 时，其余结点可分为 m(m>0) 个互不相交的有限集 T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的**子树（SubTree）**。

2. 结点拥有的子树称为**结点的度（Degree）**。度为 0 的结点称为**叶结点（Leaf）**或**终端结点**；度不为 0 的结点称为**非终端结点**或**分支结点**。除根结点之外，分支结点也称为**内部结点**。树的度是树内各结点的度的**最大值**。

3. 结点的子树的根称为该节点的**孩子（Child）**，相应地，该结点称为孩子的**双亲（Parent）**；同一个双亲的孩子之间互称**兄弟（Sibling）**；结点的**祖先**是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的**子孙**。

4. 结点的**层次（Level）**从根开始定义起，根为第一层，根的孩子为第二层。

5. 树中结点的**最大层次**称为树的**深度（Depth）**或**高度**。

6. 如果将树中结点的各子树看成从左到右是有次序的，不能互换的，则称该树为**有序树**，否则为**无序树**。

7. **森林（Forest）**是 m(m≥0) 棵互不相交的树的集合。

8. 树的存储结构：

    1. 双亲表示法

    2. 孩子表示法

    3. 孩子兄弟表示法（左孩子、右兄弟表示法）

### 二叉树
1. 二叉树（Binary Tree）是 n(n≥0) 个结点的有限集合，该集合或者为空集（称为**空二叉树**），或者由一个根节点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

2. 二叉树的特点

    - 每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。

    - 左子树和右子树是有顺序的，次序不能任意颠倒。

    - 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

3. 二叉树的五种基本形态

    - 空二叉树

    - 只有一个根结点

    - 根结点只有左子树

    - 根结点只有右子树

    - 根结点既有左子树又有右子树

4. 特殊二叉树

    1. 斜树

        所有的结点都只有左子树的二叉树叫**左斜树**；所有结点都只有右子树的树叫**右斜树**。这两者统称为**斜树**。

    2. 满二叉树

        在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为**满二叉树**。

        特点：

        1. 叶子只能出现在最下一层

        2. 非叶子结点的度一定是 2

        3. 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多

    3. 完全二叉树

        对一棵具有 n 个结点的二叉树**按层序**编号，如果编号为 i(1≤i≤n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为**完全二叉树**。

        *Tips：满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。*

        特点：

        1. 叶子结点只能出现在最下两层

        2. 最下层的叶子一定集中在左部连续位置

        3. 倒数二层，若有叶子结点，一定都在右部连续位置

        4. 如果结点度为 1，则该结点只有左孩子，即不存在只有右子树的情况

        5. 同样结点数的二叉树，完全二叉树的深度最小

5. 二叉树的性质

    1. 在二叉树的第 i 层上至多有 2<sup>i-1</sup>个结点 (i≥1)

    2. 深度为 k 的二叉树至多有 2<sup>k</sup>-1 个结点 (k≥1)

    3. 对任何一棵二叉树 T，如果其终端结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub>=n<sub>2</sub>+1

    4. 具有 n 个结点的完全二叉树的深度为 ⌊log<sub>2</sub>n⌋+1 (⌊x⌋ 表示不大于 x 的最大整数)

    5. 如果对一棵有 n 个结点的完全二叉树（其深度为 ⌊log<sub>2</sub>n⌋+1）的结点按层序编号（从第 1 层到第 ⌊log<sub>2</sub>n⌋+1 层，每层从左到右），对任一结点 i(1≤i≤n) 有：

        1. 如果 i=1，则结点 i 是二叉树的根，无双亲；如果 i>1，则其双亲是结点 ⌊i/2⌋

        2. 如果 2i>n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i

        3. 如果 2i+1>n，则结点 i 无有孩子；否则其右孩子是结点 2i+1

6. 二叉树的存储结构

    1. **二叉树顺序存储结构**：用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系（一般按完全二叉树的序号来进行分配）

    2. **二叉链表**

7. 二叉树的遍历

    1. 定义：**二叉树的遍历（traversing binary tree）**是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点**被访问一次且仅被访问一次**。

    2. 方式：

        1. 前序遍历（根左右）

        2. 中序遍历（左根右）

        3. 后序遍历（左右根）

        4. 层序遍历：若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。

8. 线索二叉树

    1. 指向前驱和后继的指针称为**线索**，加上线索的二叉链表称为**线索链表**，相应的二叉树就称为**线索二叉树（Threaded Binary Tree）**。

    2. 对二叉树以某种次序遍历使其变为线索二叉树的过程称作是**线索化**。

    3. 为了区分结点的左孩子到底是它的左孩子还是它的前驱，右孩子到底是它的右孩子还是后继，需为每个结点再增设两个**标志域（ltag 和 rtag）**，注意，ltag 和 rtag 只存放 0 和 1，为 0 时表示指向的是孩子，为 1 表示指向的是前驱或后继。

    4. 线索化的过程就是在遍历的过程中修改空指针的过程。

    5. 如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。

### 树、森林与二叉树的转换
1. 树转换成二叉树（左孩子右兄弟法）

2. 森林转换成二叉树：先把每棵树根据上面的规则转换成二叉树，再将第一棵二叉树的根结点作为根，其他二叉树的根结点作为该根结点的右孩子（即将所有的二叉树视作兄弟）

3. 森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。

### 赫夫曼树及其应用
1. 从树中一个结点到另一个结点之间的分支构成两个结点之间的**路径**，路径上的分支数目称作**路径长度**。

2. 树的路径长度就是从树根到每一个结点的路径长度之和。

3. 结点的**带权路径长度**为从该结点到树根之间的路径长度与结点上权的乘积。

4. 树的**带权路径长度**为树中所有**叶子结点**的带权路径长度之和。

5. **带权路径长度 WPL** 最小的二叉树称作赫夫曼树。

6. 一般地，设需要编码的字符集为 { d<sub>1</sub>, d<sub>2</sub>, ... , d<sub>n</sub> }，各个字符在电文中出现的次数或频率集合为 { w<sub>1</sub>, w<sub>2</sub>, ... , w<sub>n</sub> }，以 d<sub>1</sub>, d<sub>2</sub>, ... , d<sub>n</sub>作为叶子结点，以 w<sub>1</sub>, w<sub>2</sub>, ... , w<sub>n</sub> 作为相应的叶子结点的权值来构造一棵赫夫曼树。规定**赫夫曼树的左分支代表 0，右分支代表 1**，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的**编码**，这就是**赫夫曼编码**。

## 图
### 图的定义
#### 基本概念
1. **图（Graph）**是由顶点的**有穷非空**集合和定点之间边的集合组成，通常表示为：G(V, E)，其中 G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。

2. 在图中数据元素，我们称为**顶点（Vertex）**。

3. 在图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，**边集可以是空的**。

#### 各种图定义
1. 无向边：若顶点 v<sub>i</sub> 到 v<sub>j</sub> 之间的边没有方向，则称这条边为**无向边（Edge）**，用**无序偶对 (v<sub>i</sub>, v<sub>j</sub>)** 来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为**无向图（Undirected graphs）**。

2. 有向边：若顶点 v<sub>i</sub> 到 v<sub>j</sub> 的边有方向，则称这条边为**有向边**，也称为**弧（Arc）**。用**有序偶对 \<v<sub>i</sub>, v<sub>j</sub>\>** 来表示，v<sub>i</sub> 称为**弧尾（Tail）**，v<sub>j</sub> 称为**弧头（Head）**。如果图中任意两个顶点之间的边都是有向边，则称改图为**有向图（Directed graphs）**。

3. 在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为**简单图**。

4. 在无向图中，如果任意两个顶点之间都存在边，则称该图为**无向完全图**。含有 n 个顶点的无向完全图有 n*(n-1)/2 条边。

5. 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为**有向完全图**。含有 n 个顶点的有向完全图有 n*(n-1) 条边。

6. 有很少条边或弧的图称为**稀疏图**，反之称为**稠密图**。稀疏与稠密是相对的。

7. 有些图的边或弧具有与它相关的数字，这些数字称为权值，这种带权的图通常称为**网（Network）**。

8. 假设有两个图 G=(V, {E}) 和 G'=(V', {E'})，如果 V'属于 V 且 E' 属于 E，则称 G' 为 G 的**子图（Subgraph）**。

#### 图的顶点与边的关系
1. 对于无向图 G=(V, {E})，如果边 (v, v')∈E，则称顶点 v 和 v' 互为**邻接点（Adjacent）**，即 v 和 v' 相邻接。边 (v, v') **依附（incident）**于顶点 v 和 v'，或者说 (v, v') 与顶点 v 和 v' 相**关联**。

2. 顶点的**度（Degree）**是和该顶点相关联的边的数目。记为 TD(v)。

3. 对于有向图 G=(V, {E})，如果弧 \<v, v'\>∈E，则称顶点 v 邻接**到**顶点 v' ，顶点 v' 邻接**自**顶点 v。弧 \<v, v'\> 和顶点 v，v' 相关联。以顶点 v 为**头**的弧的数目称为 v 的**入度（InDegree）**，记为 ID(v)；以 v 为**尾**的弧的数目称为 v 的**出度（OutDegree）**，记为 OD(v)；顶点 v 的度为 TD(v)=ID(v)+OD(v)。

4. 无向图 G=(V, {E}) 中从顶点 v 到顶点 v' 的**路径（Path）**是一个顶点序列（v=v<sub>i,0</sub>, v<sub>i,1</sub>, ... , v<sub>i,m</sub>=v'），其中 (v<sub>i,j-1</sub>, v<sub>i, j</sub>)∈E, 1≤j≤m。

5. 路径的长度是路径上的边或弧的数目。

6. 第一个顶点到最后一个顶点相同的路径称为**回路**或**环（Cycle）**。

#### 连通图相关术语
1. 在无向图 G 中，如果从顶点 v 到顶点 v' 有路径，则称 v 和 v' 是连通的。如果对于图中任意两个顶点 v<sub>i</sub>、v<sub>j</sub>∈V, v<sub>i</sub> 和 v<sub>j</sub> 都是连通的，则称 G 是**连通图（Connected Graph）**。

2. 无向图中的**极大**连通子图称为**连通分量**。

3. 在有向图 G 中，如果对于每一对 v<sub>i</sub>、v<sub>j</sub>∈V、v<sub>i</sub>≠v<sub>j</sub>，从 v<sub>i</sub> 到 v<sub>j</sub> 都存在路径，则称 G 是**强连通图**。有向图中的极大强连通子图称作有向图的**强连通分量**。

4. 一个连通图的**生成树**是一个极小的连通子图，它含有图中全部的 n 个顶点，但只有足以构成一棵树的 n-1 条边。

5. 一个图，有 n 个顶点，如果有小于 n-1 条边，则这个图是非连通图，如果有多于 n-1 条边，则必定存在环，但是，**就算有 n-1 条边也不一定是连通图**。

6. 如果一个有向图恰有一个顶点入度为0，其余顶点的入度均为1，则是一棵**有向树**。

7. 一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。

### 图的存储结构
1. 邻接矩阵：

    图的**邻接矩阵（Adjacency Matrix）**存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。

2. 邻接表：

    将数组与链表相结合的存储方式称为**邻接表（Adjacency List）**

    其中，图中顶点用一个以为数组存储，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针。

3. 十字链表（Orthogonal List）

4. 邻接多重表

5. 边集数组

    边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的**起点下标（begin）**、**终点下标（end）**和**权（weight）**组成。

### 图的遍历
1. 概念

    从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫**图的遍历（Traversing Graph）**。

2. 深度优先遍历（Depth First Search），也有称为**深度优先搜索**，简称为 DFS。

3. 广度优先遍历（Breadth First Search），又称为**广度优先搜索**，简称为 BFS。