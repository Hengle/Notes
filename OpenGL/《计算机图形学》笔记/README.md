# 《计算机图形学》笔记
## 第一章 计算机图形学概述
### 什么是计算机图形学
计算机图形学是研究怎样用计算机表示、处理和显示图形的一门学科

### 什么是计算机图形学
- **图形（graphics）**：计算机图形学的研究对象

    + 能在人的视觉系统中产生视觉印象的客观对象
    + 包括自然景物、拍摄到的图片、用数学方法描述的图形等

- 构成图片的要素

    + 几何要素：刻画对象的轮廓、形状的点、线、面、体等
    + 非几何要素：刻画对象的颜色、材质、纹理、线型、线宽等

### 表示图形的方法
- 参数表示

    由图形的形状参数（方程或分析表达式的系数，线段的端点坐标等）+ 属性参数（颜色、线型等）来表示图形

    称为**参数图**或**图形（graphics）**

- 点阵表示

    枚举出图形中所有的点（强调图形由点构成）

    称为**像素图**或**图像（image，数字图像）**

### 图形与图像
- **图形**含有几何属性，或者说更强调场景的几何表示，是由场景的几何模型和物理属性共同描述

- **图像**纯指计算机内以位图形式表示的颜色和亮度信息

图形 --（光栅化或扫描转换）--> 图像

|图形|图像|
|:---:|:---:|
|有结构，便于编辑修改|无结构，不易编辑修改|
|能准确表示3D景物，易于生成所需的不同视图|3D景物的信息已部分丢失，很难生成不同的视图|
|生成视图需要复杂的计算|生成视图不需要复杂的计算|
|自然景物的表示很困难|自然景物的表示不困难|
|国际标准：PHIGS，STEP，OpenGL等|国际标准：JPEG，TIFF等|
|编辑软件：AutoCAD，CorelDraw|编辑软件：Photoshop|


## 第二章 计算机图形系统
### 像素与光栅
- 现代图形系统都是基于光栅的，在输出设备上看到的图像都是图形元素组成的阵列

- **像素（pixel=picture element）**：图像的基本单元。每个像素对应于图像中的某个位置或某个小区域

- **光栅（raster）**：像素的阵列

### 帧缓冲区
- **帧缓冲区（frame buffer）**：图形系统的核心部件，存储屏幕上像素的颜色信息。帧缓冲区是屏幕所显示画面的一个直接映象

- 帧缓存的每一存储单元对应屏幕上的一个像素，整个帧缓存对应一帧图像

- **分辨率（resolution）**：帧缓冲区中像素的个数。它决定了我们看到的图像的精细程度

- **深度（depth）**或**精度（precision）**：每个像素的位数

*注：全彩（真彩）色：24位，2<sup>24</sup>种颜色。也称为RGB-颜色，每个像素被赋予红、绿、蓝三基色颜色组（各8位）*

### 成像系统的三要素
- 物体/对象

- 观察者（人、照相机）

- 光源

*注：材质的属性确定光照射在物体上的效果。且对象、观察者以及光源是完全独立的*

### 亮度图像与彩色图像
- 亮度图像（luminance image）

    + 单色图像
    + 值为灰度等级
    + 类似于黑白电影和电视

- 彩色图像（color image）

    + 可以显示出色调（hue），饱和度（saturation）和亮度（lightness）
    + 不一定匹配可见光谱中的波长

### 强度和亮度
- 强度：光线能量的物理度量

- 亮度：度量我们所感知到的物体发射出的光线有多强

### 成像过程
四个主要步骤：

1. 顶点处理

2. 裁剪和图元装配

3. 光栅化

4. 片段处理

> 顶点（应用程序）→顶点处理器→ 裁剪器与图元装配器→ 光栅化器→ 片段处理器→ 像素（显示设备）

## 第三章 OpenGL 编程
### 关于 GL、GLU、GLUT 通俗的解释
- OpenGL 中的 GL 库（OpenGL Core Library）是核心库，GLU 库（OpenGL Utility Library）是实用库， GLUT 库（OpenGL Utility Toolkit Library） 库是实用工具库

- GL 是核心，GLU 是对 GL 的部分封装，GLUT 是 OpenGL 的跨平台工具库

- GL 中包含了最基本的 3D 函数，而 GLU 是对 GL 的辅助，如果数学好，不用 GLU 的情况下，也是可以做出同样的效果

- GLUT 是基本的窗口界面，是独立于 GL 和 GLU 的。如果不喜欢用 GLUT，也可以用 MFC 等代替，但是 GLUT 是跨平台的

### OpenGL 的函数
- **图元函数（primitive）**

    系统可以显示的低级对象或最基本的实体，包括点、线段、多边形、像素、文本和各种曲线/曲面等

- **属性函数（attribute）**

    控制图元在显示器上显示的方式：线段颜色、多边形填充模式、图标题文本的字体等

- **视图函数（viewing）**

    设置虚拟照相机的位置、朝向和镜头参数等

- **变换函数（transformation）**

    对对象进行诸如平移、旋转和缩放等变换操作

- **输入函数（input）**

    处理来自键盘、鼠标等设备的输入

- **控制函数（control）**

    与窗口系统通信，初始化程序，处理运行时的错误等

- **查询函数（query）**

    确定特定系统或设备的性能参数，查询相机参数、帧缓冲区等 API 相关的信息

### OpenGL 的状态
OpenGL 是一个**有限状态机（state machine）**的黑盒：

- 状态：持续性参数，如颜色、线型、材质属性等
- 来自应用程序的输入改变 machine 的状态或者产生可见的输出

因此，OpenGL 函数可归纳为**两大类型**：

1. 定义图元

    - 如果图元可见，则被输出
    - 顶点如何被处理以及图元的外观由状态控制

2. 改变状态

    - 属性函数、视图函数、变换函数、查询函数
    - 在 3.1 以后版本，大部分状态变量由应用程序定义并发送到着色器

### OpenGL 程序的一般结构
> 配置并开启窗口 → 初始化 OpenGL 状态 → 处理用户事件 ↔️ 绘制图像

### OpenGL GLUT 回调函数
GLUT 使用回调函数机制来进行事件处理

- 窗口绘制 `glutDisplayFunc()`

- 窗口重绘 `glutPostRedisplay()`

- 窗口改变大小 `glutReshapeFunc()`

- 键盘输入 `glutKeyboardFunc()`

- 鼠标按键 `glutMouseFunc()`

- 鼠标移动 `glutMotionFunc()`

- 空闲函数 `glutIdleFunc()`

### 视图（Viewing）
- 虚拟照相机模型：对象与照相机相互独立

    应用程序只需关心对象和照相机的参数设置

- 照相机只能“看到”处于**视域体**内的对象。因此，要指出照相机在场景中的位置以及投影方式——称为**“视图”方式**

- OpenGL 默认视图：**正交投影**

    镜头焦距无限大，无限远离对象

    极限情形下，投影线彼此平行，投影中心变为投影方向

    投影线与投影平面垂直

- 正交投影可以对位于照相机后面的对象成像

### 变换与视图
在 OpenGL 中投影是利用投影矩阵乘法（变换）进行的

由于只存在一个变换函数系列，因此必须先设置矩阵类型：`glMatrixMode(GL_PROJECTION)`

变换函数是累计在一起的，因此需要从单位阵开始，然后把它改变为一个定义正交投影视景体的投影矩阵：

```python
glLoadIdentity()
glOrtho(-1, 1, -1, 1, -1, 1)
```

### OpenGL 的几何图元
|名称|对应常量|
|:---:|:---:|
|点|GL_POINTS|
|线段|GL_LINES|
|开折线|GL\_LINE\_STRIP|
|封闭折线|GL\_LINE\_LOOP|
|多边形|GL_POLYGON|
|四边形|GL_QUADS|
|三角形|GL_TRIANGLES|
|三角形带|GL\_TRIANGLE\_STRIP|
|四边形带|GL\_QUAD\_STRIP|
|三角形扇|GL\_TRIANGLE\_FAN|

### 图元的属性
**属性（attribute）**决定图元将如何绘制，是OpenGL 状态的一部分

|图元|属性|
|:---:|:---:|
|点|颜色、大小|
|线段|颜色、宽度、模式（实线、虚线）|
|多边形|绘制模式、填充模式|
|笔划文本|字体、字号、方向|

### 颜色与状态
由`glColor()`设置的颜色成为状态的一部分，后续构造过程将使用这一颜色，直至它被修改为止

*注：颜色与其他属性不是对象的一部分，但是在渲染对象时要把这些属性赋给对象*

### 着色模型
默认状态是**平滑着色**，OpenGL 根据多边形顶点的颜色插值出来内部的颜色

另一种状态是**平面着色**，第一个顶点的颜色确定填充颜色

设置着色模型`glShadeModel(Glenum mode)`:

- 平滑模式：`GL_SMOOTH`

- 平面模式：`GL_FLAT`

### 宽高比
**宽高比（aspect ratio）**：矩形的宽度与高度之比

如果`glOrtho`和`glutInitWindowSize`设置举行的宽高比不同，则会引起对象变形

原因在于，默认的操作方式是把整个裁剪矩形映射到显示窗口里，保证宽高比


## 第四章 输入与交互
### 输入模式
在输入设备中具有一个**触发器（trigger）**，它可以向操作系统发送一个信号

- 鼠标上的按钮

- 按下/释放键盘上的按键

当触发后，输入设备向系统返回信息，即相应的**测量值（measure）**

- 鼠标返回位置信息

- 键盘返回 ASCII 码

输入模式有三种：**采样模式**、**请求模式**、**事件模式**

### 请求模式（Request Mode）
只有当用户出发了设备后，输入才提供给程序

例如：键盘在按回车键之前，可以删除、编辑、修改输入的信息

用户必须指明哪个输入设备提供输入

适合程序引导用户的情形，而不适合用户控制程序执行过程

> 触发过程 → 测量过程 ↔️ 应用程序

### 采样模式（Sample Mode）
测量数据即时返回给程序，不需要触发器

适合程序引导用户的情形，而不适合用户控制程序执行过程

> 测量过程 ↔️ 应用程序

### 事件模式（Event Mode）
绝大部分系统具有多个输入设备，每个设备都可能被用户在任意时间触发

每个触发生成一个事件，事件的测量值放到**事件队列**中，用户程序检查该队列，根据事件的类型采用相应的操作（回调函数）

> 触发过程 → 测量处理 → 事件队列 ↔️ 应用程序

### 事件类型
|组件|事件|
|:---:|:---:|
|窗口|改变尺寸、重新显示、缩成图标|
|鼠标|点击一个或多个按钮，移动|
|键盘|按下或释放某个键|
|空闲|特殊事件（当事件队列中没有其他事件而执行的特殊事件）|

### 鼠标回调事件
- 注册：

```cpp
glutMouseFunc(mouse)
```

- 定义：

```cpp
void mouse(int button, int state, int x, int y)
```

其中`button`的值可能是：`GLUT_LEFT_BUTTON`、`GLUT_MIDDLE_BUTTON`、`GLUT_RIGHT_BUTTON`，分别对应鼠标的左键、中键及右键

`state`表示相应按钮的状态：`GLUT_UP`、`GLUT_DOWN`，分别表示鼠标释放、按下

`x`、`y`表示鼠标在窗口中的位置

### 鼠标移动回调函数
- 注册：

```cpp
glutMotionFunc(mouse_motion) // 按下鼠标的情况下移动

glutPassiveMotionFunc(mouse_motion) // 不按下鼠标的情况下移动
```

- 定义：

```cpp
void mouse_motion(int x, int y)
```

其中`x`、`y`表示鼠标在窗口中的位置

### 键盘的使用
- 注册：

```cpp
glutKeyboardFunc(keyboard)
```

- 定义：

```cpp
void keyboard(unsigned char key, int x, int y)
```

其中`key`为键盘上被按下键的 ASCII 码

`x`、`y`表示鼠标在窗口中的位置

*注：*

*特殊按键，如`F1`，`UP`键等，在 GLUT 中定义了常量：`GLUT_KEY_F1`、`GLUT_KEY_UP`，并且需要采用特殊函数注册回调函数：*

```cpp
void glutSpecialFunc(void (*func) (int key, int x, int y))
```

*如果在鼠标或键盘事件产生是按下修饰键，如`Ctrl`、`Alt`、`Shift`，则需要使用`int glutGetModifiers()`函数来进行捕获，其返回值为：`GLUT_ACTIVE_SHIFT`、`GLUT_ACTIVE_CTRL`、`GLUT_ACTIVE_ALT`*

### 窗口改变大小回调函数
- 注册：

```cpp
glutReshapeFunc(reshape)
```

- 定义：

```cpp
void reshape(int w, int h)
```

其中`w`、`h`是新窗口的宽度和高度（单位：像素）

回调函数执行后自动发送刷新显示事件，触发显示回调函数

GLUT 新建窗口时会调用该回调函数，其中，通过调用`glViewport(0, 0, w, h)`可以把新窗口设置为视口

*注：这个回调函数是放置照相机函数的恰当地方，因为当窗口首次创建时就会调用它。可以将视景体的大小位置的设置`glOrtho`以及`glViewport`放置在此*

### 空闲回调函数
- 注册：

```cpp
glutIdleFunc(idle)
```

- 定义：

```cpp
void idle()
```

当事件队列中没有事件时，就执行该回调函数

### 构件（widgets）
许多窗口系统提供了一个工具包或者一组库函数用来建立用户界面，界面中用到了一些特殊类型的窗口，称为**构件（widgets）**

### 菜单（menu）
GLUT 支持弹出式菜单，且可以有子菜单

创建弹出式菜单的三个步骤

1. 定义菜单内各条目

2. 定义每个菜单项的行为（即如果该条目被选择，要执行的操作）

3. 把菜单连接到鼠标按钮上

### 菜单函数
- `int glutCreateMenu(void (*func) (int value))`

    创建一个使用回调函数`func()`的菜单，并返回该菜单的整数标识符

- `void glutAddMenuEntry(char *name, int value)`

    为当前菜单添加一个名为`name`的菜单项，`value`值由用户给定，当被选中时返回给菜单回调函数

- `void glutAttachMenu(int button)`

    将当前菜单关联到鼠标按钮`button`上（`button`值为`GLUT_RIGHT_BUTTON`、`GLUT_LEFT_BUTTON`、`GLUT_MIDDLE_BUTTON`）

- `void glutAddSubMenu(char * submenu_name, int submenu_id)`

    增加一个子菜单项，`submenu_name`作为当前菜单的一项，`submenu_id`为该子菜单在创建时返回的标识符

    **必须先创建子菜单，再创建上一级菜单**

### 窗口函数
- `int glutCreateWindow(char *name)`

    创建一个顶层窗口`name`，并为其返回一个整数标识符

- `void glutDestroyWindow(int id)`

    销毁标识符为`id`的窗口

- `void glutSetWindow(int id)`

    把当前窗口设为标识符为`id`的窗口

- `int glutCreateSubWindow(int parent, int x, int y, int width, int height)`

    为`parent`窗口创建一个子窗口，返回子窗口的标识符。子窗口原点位于(x, y)，宽度为`width`，高度为`height`

- `void glutPostWindowRedisplay(int id)`

    通知标识符为`id`的窗口重新显示

## 第五章 几何对象与变换
### 矢量空间与仿射空间
- **标量场**：包括实数、复数和有理函数

- **矢量空间**：包括标量和矢量

    矢量空间里的一个重要概念是：任何一个矢量都可以唯一地用基向量来表示

一个矢量空间加上大小或距离的测量值，以及定义线段长度等概念，就成为一个**欧几里得空间**

一个矢量空间加上点，就成为**仿射空间**

在这些抽象空间里，对象的定义不依赖于某种特定的表示方法，它们仅是各种不同集合的成员

不同表示之间的相互转换就得到了**几何变换**

### 基本几何要素与几何对象
三个基本几何要素：

- 标量

- 点

- 矢量

最基本的几何对象是**点**

在三维几何空间里，点是空间里的一个位置。在数学概念上，点既无大小，也无形状

用实数表示点与点之间的距离，是标量。复数、有理函数也是标量

任何有方向有大小的量称为矢量。矢量在空间中没有固定的位置。在计算机图形学里，矢量常被称为**有向线段**

### 齐次坐标
四维齐次坐标的一般形式为：

`p = [x, y, z, w]<sup>T</sup>`

可以通过下述方法给出三维点（当`w≠0`时）：

```
x ← x / w
y ← y / w
z ← z / w
```

当`w=0`时，表示对应的是一个向量

*注：齐次坐标表示中把四维空间中过原点的一条直线对应于三维空间中的一个点*

### 齐次坐标与计算机图形学
齐次坐标是所有计算机图形系统的关键：

- 所有标准变换（旋转、平移、放缩）都可以应用 4×4 阶矩阵的乘法实现

- 硬件流水线体系采用四维表示

- 对于正交投影，可以通过`w=0`保证向量，`w=1`保证点

- 对于透视投影，需要进行特殊的处理：**透视除法（perspective division）**

### 表示的变换
在两个框架中任意点和向量具有同样形式的表示

在第一个框架中：a = [α<sub>1</sub>, α<sub>2</sub>, α<sub>3</sub>, α<sub>4</sub>]<sup>T</sup>

在第二个框架中：b = [β<sub>1</sub>, β<sub>2</sub>, β<sub>3</sub>, β<sub>4</sub>]<sup>T</sup>

其中，表示的是点时，α<sub>4</sub> = β<sub>4</sub> = 1；表示的是向量时，α<sub>4</sub> = β<sub>4</sub> = 0，并且

**a=Mb**

**b=M<sup>-1</sup>a=Ta**

矩阵 M 是 4×4 阶，定义了齐次坐标下的一个仿射变换

### 变换
- 线性变换与仿射变换

- 标准变换

    - 平移 translation
    - 旋转 rotation
    - 缩放 scaling
    - 错切 shear

- 复杂变换

### OpenGL 中的矩阵
在 OpenGL 中，矩阵是状态的一部分

矩阵有多种类型：

- 模型视图（`GL_MODELVIEW`)

- 投影（`GL_PROJECTION`）

- 纹理（`GL_TEXTURE`）

- 颜色（`GL_COLOR`）

所有的矩阵都是由一组共同的函数来设置或修改：`glMatrixMode(mode)`


### 通用变换函数
- `void glMatrixMode(Glenum mode)`

    指定要修改的矩阵类型：`GL_MODELVIEW`、`GL_PROJECTION`、`GL_TEXTURE`、`GL_COLOR`

- `void glLoadIdentity(void)`

    把当前矩阵设置为 4×4 单位阵

- `void glLoadMatrix(constTYPE *m)`

    把当前矩阵的 16 个值设置为 m 所指定的值

- `void glMultMatrix(constTYPE *m)`

    把当前矩阵右乘由 m 的 16 个值构成的矩阵

- `void glRotate(theta, Vx, Vy, Vz)`

    以原点为旋转固定点，以 (Vx, Vy, Vz) 为旋转轴，旋转`theta`角度；其中`theta`以角度为单位

- `void glTranslate(Dx, Dy, Dz)`

    对象上的所有点沿同一个方向移动 (Dx, Dy, Dz)

- `void glScale(Sx, Sy, Sz)`

    以原点为中心缩放

### 矩阵堆栈
很多情况中需要保存变换矩阵，待稍后在用，例如：

- 遍历层次数据结构

- 当执行显示列表时避免状态改变

- 不同对象有不同的变换矩阵

OpenGL 为每种类型的矩阵保持一个堆栈：

- 模型-视图矩阵堆栈：32 个 4×4 矩阵

- 投影矩阵堆栈：2 个 4×4 矩阵

应用下列函数处理矩阵堆栈：

- `void glLoadIdentity()`

    将矩阵堆栈中的栈顶置为单位矩阵

- `void glPushMatrix()`

    当前矩阵堆栈中的矩阵下压一级，复制当前矩阵，拷贝到栈顶。最顶部的两个矩阵相同

- `glPopMatrix()`

    弹出并丢弃栈顶矩阵

*注：应先由`glMatrixMode(mode)`设置矩阵类型*

## 第六章 观察
### 视图中的三个基本要素
- 一个或多个对象

- 观察者，带有一个投影面

- 从对象到投影平面的投影线

### 平面几何投影分类
- 平行投影：

    - 多视点正交投影

    - 轴测投影（axonometric）

        - 正等轴测（isometric）

        - 正二轴测（dimetric）

        - 正三轴测（trimetric）

    - 斜投影（oblique）

- 透视投影

    - 单点

    - 两点

    - 三点

### 计算机视图
视图有三个功能，都在流水线结构中实现：

- 定位照相机

- 设置镜头

- 裁剪（设置视景体）

### 透视变换
透视方程是非线性的，导致**非均匀透视缩短（nonuniform foreshortening）**

离 COP 远的对象投影后尺寸缩短得比离 COP 近的对象大

透视变换是保直线的，但不是仿射变换

透视变换是不可逆的，因为沿一条投影直线上的所有点投影后的结果相同，无法从投影点恢复原来的点

### 投影流水线
在模型-视图矩阵后应用 4×4 的投影矩阵可以实现简单的透视投影，但在最后需要进行透视除法

透视除法成为流水线的一部分

> → Model-view → Projection → Perspective division →


